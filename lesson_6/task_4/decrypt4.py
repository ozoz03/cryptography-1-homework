from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes
import numpy
import math

n = 30460296206281253605887131667441042408833105116654370140736576080711297109384941590369941855116386695157474206375705248890458232777575365270780855265861075198881090190505284920581410885950363830131451127387018904728639607372668753109249046707840464876881594185896506371262697868257217488062754637361594352910022190227237953540282162231147699265142164623465337280610190892470279654386272723760887111753067292988287956381022028725288845603024605833650847697724636088418782911705757980221361510892370739837402705040814150778298018509675199917931423568797098139493145394232981571448400646089157848498064505852923746440139
e = 3
ct = 183001753190025751114220069887230720857448492282044619321040127443487542179613757444809112210217896463899655491288132907560322811734646233820773

def calculate_cube_root(value):
    high = 1
    while high ** 3 < value:
        high *= 2
    low = high // 2
    while low < high:
        mid = (low + high) // 2
        if low < mid and mid ** 3 < value:
            low = mid
        elif high > mid and mid ** 3 > value:
            high = mid
        else:
            return mid
    return mid + 1

# ct = (pt**e) % n
# e = 3
# ct = pt**3 % n
# ct = k * n + pt**3
# pt**3 = ct - k * n

# pt = (ct- k*n)**(1/3)
# pt = math.cbrt(ct)
# pt = pow((ct-k*n),(1/3))
# 
k=0
pt = calculate_cube_root((ct-k*n))
print(pt)     
decrypted = long_to_bytes(pt)
print(decrypted)
# b'crypto{robot_dreams}'

